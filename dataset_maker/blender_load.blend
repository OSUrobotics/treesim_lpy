import bpy
import glob
import numpy as np
import mathutils
import math

def create_sine(numCycles = 1, stepsPerCycle = 16, curvelen=2, zscale=1, offset = (0,0,0), noise_var = (0,0,0)):

    curve = bpy.data.curves.new('path', type='CURVE')
    curve.dimensions = '2D'
    curve.resolution_u = 1
    spline = curve.splines.new('NURBS')
    
    #cursor = bpy.context.scene.cursor_location
    xscale = float(curvelen)/stepsPerCycle/numCycles
    
    for x in range(0, stepsPerCycle * numCycles+1):
        noise = np.random.normal(loc=0.0, scale=noise_var, size=3)
        z = math.sin(float(x) / stepsPerCycle * math.pi*2) 

        #Add first point for start of Nurbs (needs extra point)
        if x == 0:
            spline.points[0].co = (x*xscale+offset[0]+noise[0], 0+offset[1]+noise[1], z*zscale+offset[2]+noise[2],1) 

        # Add point
        spline.points.add(1)
        spline.points[-1].co = ((x*xscale+offset[0]+noise[0], 0+offset[1]+noise[1], z*zscale+offset[2]+noise[2],1))
    # Add end point
    spline.points.add(1)
    spline.points[-1].co =(x*xscale+offset[0]+noise[0], 0+offset[1]+noise[1], z*zscale+offset[2]+noise[2],1)
    curveObject = bpy.data.objects.new('campath', curve)
    bpy.context.scene.collection.objects.link(curveObject)

def new_plane(mylocation, mysize, myname):
    bpy.ops.mesh.primitive_plane_add(
        size=mysize,
        align='WORLD',
        location=mylocation,
        rotation=(0,0,0),
        scale=(1,1,1))
    current_name = bpy.context.selected_objects[0].name
    plane = bpy.data.objects[current_name]
    plane.name = myname
    plane.data.name = myname + "_mesh"
    return

def create_new_material_with_vertex_colors(name):
    materials = bpy.data.materials
    mat_name = 'mat_{}'.format(name)
    material = materials.get( mat_name )

    if not material:
        material = materials.new( mat_name )

    # We clear it as we'll define it completely
    clear_material( material )
    material.use_nodes = True
    nodes = material.node_tree.nodes
    links = material.node_tree.links
    output = nodes.new( type = 'ShaderNodeOutputMaterial' )
    diffuse = nodes.new( type = 'ShaderNodeBsdfDiffuse' )
    input = nodes.new( type = 'ShaderNodeVertexColor')
    link = links.new( input.outputs['Color'], diffuse.inputs['Color'])
    link = links.new( diffuse.outputs['BSDF'], output.inputs['Surface'] )
    
    if obj.data.materials:
        # assign to 1st material slot
        obj.data.materials[0] = material
    else:
        # no slots
        obj.data.materials.append(material)

def create_new_material_with_rgb_colors(name):
    materials = bpy.data.materials
    mat_name = 'mat_{}'.format(name)
    material = materials.get( mat_name )

    if not material:
        material = materials.new( mat_name )

    # We clear it as we'll define it completely
    clear_material( material )
    material.use_nodes = True
    nodes = material.node_tree.nodes
    links = material.node_tree.links
    diffuse = nodes.new( type = 'ShaderNodeBsdfDiffuse' )
    output = nodes.new( type = 'ShaderNodeOutputMaterial' )
    input = nodes.new( type = 'ShaderNodeRGB')
    input.outputs['Color'].default_value = mathutils.Vector((0, 0, 0, 0))
    link = links.new( input.outputs['Color'], diffuse.inputs['Color'])
    link = links.new( diffuse.outputs['BSDF'], output.inputs['Surface'] )
    
    if obj.data.materials:
        # assign to 1st material slot
        obj.data.materials[0] = material
    else:
        # no slots
        obj.data.materials.append(material)

noise_var = [0]

for noise_var_value in noise_var:
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete()
    create_sine(numCycles = 40, stepsPerCycle = 16, zscale=10,curvelen=100, offset = (-50, 30, 10), noise_var = (0,noise_var_value,0))
    curve = bpy.context.scene.objects["campath"]
     # create the first camera
    cam = bpy.data.cameras.new("Camera")

    cam.lens = 18

    # create the first camera object
    
    cam_obj = bpy.data.objects.new("Camera", cam)
    cam_obj.location = (0,0,0)
    cam_obj.rotation_euler = mathutils.Euler((np.pi/2,0,-np.pi/2), 'XYZ')
   
    bpy.context.scene.collection.objects.link(cam_obj)
    
    cam_obj.select_set(True)
    curve.select_set(True)
    bpy.context.view_layer.objects.active = curve
    bpy.ops.object.parent_set(type='FOLLOW')
    bpy.context.object.track_axis = 'NEG_Y'

    
    for label in [True, False]:
        bpy.ops.object.select_all(action='SELECT')
        bpy.context.scene.objects["campath"].select_set(False)
        bpy.context.scene.objects["Camera"].select_set(False)
        bpy.ops.object.delete()
        print(label, noise_var_value)
        if label:
            folder_path = "/Users/abhinav/Library/CloudStorage/Box-Box/gradstuff/research/digitaltwin/digital_twin_lpy/dataset_maker/dataset/labelled"
        else:
            folder_path = "/Users/abhinav/Library/CloudStorage/Box-Box/gradstuff/research/digitaltwin/digital_twin_lpy/dataset_maker/dataset/unlabelled"
        

        for files in glob.glob("{}/*.x3d".format(folder_path)):
            print( files )
            bpy.ops.import_scene.x3d(filepath=files)
            bpy.context.selected_objects[0].name = 'tree'
        # Clear all nodes in a mat
        def clear_material( material ):
            if material.node_tree:
                material.node_tree.links.clear()
                material.node_tree.nodes.clear()

        # Create a node corresponding to a defined group
        def instanciate_group( nodes, group_name ):
            group = nodes.new( type = 'ShaderNodeGroup' )
            group.node_tree = bpy.data.node_groups[group_name]

        nx, ny = (5,5)
        a = np.linspace(-50, 50, nx)  
        b = np.linspace(-25, 25, ny)  
        xa, xb = np.meshgrid(a, b) 
        coordinate_grid = np.array([xa, xb]).reshape(2,-1)

        for num, obj in enumerate(bpy.data.objects[1:-1]):
            print(obj.name)
            if obj.name == "campath":
                num-=1
                continue
            x,y = (coordinate_grid[0, num], coordinate_grid[1,num])
            print(x,y)
            obj.location = mathutils.Vector((x,y, 0))
            obj.rotation_euler = mathutils.Euler((0,0,0), 'XYZ')
            #print((coordinate_grid[0,num], coordinate_grid[1,num], 0))
            materials = bpy.data.materials

            mat_name = 'mat_{}'.format(num)

            material = materials.get( mat_name )

            if not material:
                material = materials.new( mat_name )

            # We clear it as we'll define it completely
            clear_material( material )
            material.use_nodes = True
            nodes = material.node_tree.nodes
            links = material.node_tree.links
           
            if y != coordinate_grid[1,-1] and label:
                diffuse = nodes.new( type = 'ShaderNodeBsdfDiffuse' )
                output = nodes.new( type = 'ShaderNodeOutputMaterial' )
                input = nodes.new( type = 'ShaderNodeRGB')
                input.outputs['Color'].default_value = mathutils.Vector((0, 0, 0, 0))
            else:
                output = nodes.new( type = 'ShaderNodeOutputMaterial' )
                diffuse = nodes.new( type = 'ShaderNodeBsdfDiffuse' )
                input = nodes.new( type = 'ShaderNodeVertexColor')

                #With names
            link = links.new( input.outputs['Color'], diffuse.inputs['Color'])
            link = links.new( diffuse.outputs['BSDF'], output.inputs['Surface'] )
            
            if obj.data.materials:
                # assign to 1st material slot
                obj.data.materials[0] = material
            else:
                # no slots
                obj.data.materials.append(material)
                
        new_plane((0,0,0), 150, 'ground')
        plane = bpy.data.objects['ground']
        mat_name = 'asd'
        material = materials.get( mat_name )
        if not material:
            material = materials.new( mat_name )

        # We clear it as we'll define it completely
        clear_material( material )
        material.use_nodes = True
        nodes = material.node_tree.nodes
        links = material.node_tree.links
        diffuse = nodes.new( type = 'ShaderNodeBsdfDiffuse' )
        output = nodes.new( type = 'ShaderNodeOutputMaterial' )
        input = nodes.new( type = 'ShaderNodeRGB')
        input.outputs['Color'].default_value = mathutils.Vector((0.6,0.2,0.,1))
        link = links.new( input.outputs['Color'], diffuse.inputs['Color'])
        link = links.new( diffuse.outputs['BSDF'], output.inputs['Surface'] )
        if plane.data.materials:
            # assign to 1st material slot
            plane.data.materials[0] = material
        else:
            # no slots
            plane.data.materials.append(material)
        
        

        bpy.ops.object.select_all(action='DESELECT')
        bpy.context.scene.camera = cam_obj


       
        if label:
            bpy.context.scene.render.filepath = '/Users/abhinav/Desktop/blender/noise{}/labelled.avi'.format(noise_var_value)
        else:
            bpy.context.scene.render.filepath = '/Users/abhinav/Desktop/blender/noise{}/unlabelled.avi'.format(noise_var_value)
        bpy.context.scene.render.resolution_x = 1024 #perhaps set resolution in code
        bpy.context.scene.render.resolution_y = 1024
        curve.data.path_duration = 5000
        bpy.ops.render.render(animation = True, write_still = False)
        #bpy.ops.render.render(animation=True)
        #print(cam_obj.select_get())
        #bpy.ops.object.parent_set(type='FOLLOW')
